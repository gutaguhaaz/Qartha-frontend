ğŸ¯ PROMPT MEJORADO - MÃ“DULO CONTRACTS PARA ANGULAR
Quiero crear un mÃ³dulo standalone en Angular llamado contracts dentro de la ruta src/app/modules/contracts/. AquÃ­ estÃ¡n los detalles:

ğŸ§± Estructura de archivos:
src/app/modules/contracts/
â”œâ”€â”€ contracts.module.ts
â”œâ”€â”€ contracts-routing.module.ts
â”œâ”€â”€ services/
â”‚   â””â”€â”€ contracts.service.ts
â”œâ”€â”€ create-contract/
â”‚   â”œâ”€â”€ create-contract.component.ts
â”‚   â”œâ”€â”€ create-contract.component.html
â”‚   â””â”€â”€ create-contract.component.scss
â”œâ”€â”€ clause-generator/
â”‚   â”œâ”€â”€ clause-generator.component.ts
â”‚   â”œâ”€â”€ clause-generator.component.html
â”‚   â””â”€â”€ clause-generator.component.scss
â””â”€â”€ models/
    â””â”€â”€ contract.models.ts
ğŸ“Œ Routing:
Ruta principal: /contracts
CreateContractComponent en /contracts/generate
ClauseGeneratorComponent en /contracts/generate-clause
ğŸ“„ CreateContractComponent:
Formulario reactivo que incluya:
Dropdown: Seleccionar tipo de contrato (obtener opciones desde /api/v1/templates)
Campos dinÃ¡micos: Se mostrarÃ¡n segÃºn campos que devuelva /api/v1/test-template/{name}
Textarea: Para clÃ¡usulas extra (opcional)
BotÃ³n: "Generar contrato"
Al hacer clic: Enviar POST a /api/v1/generate-contract y descargar el .docx automÃ¡ticamente
Funcionalidad extra: BotÃ³n "Descargar plantilla original" usando /api/v1/download-template/{name}
ğŸ’¬ ClauseGeneratorComponent:
Textarea: Para prompt libre del usuario
BotÃ³n: "Generar clÃ¡usula con IA"
Llamar: POST /api/v1/generate-clause-gpt y mostrar la respuesta
BotÃ³n: "Insertar en contrato" (almacenar la clÃ¡usula para el componente padre)
ğŸ”Œ Endpoints del Backend (YA IMPLEMENTADOS):
// En contracts.service.ts
getTemplates() // GET /api/v1/templates
getTemplateFields(templateName: string) // GET /api/v1/test-template/{name}
generateContract(request: ContractGenerateRequest) // POST /api/v1/generate-contract
downloadTemplate(templateName: string) // GET /api/v1/download-template/{name}
generateClause(prompt: string) // POST /api/v1/generate-clause-gpt
ğŸ“ Modelos TypeScript (crear contracts.models.ts):
export interface ContractGenerateRequest {
  tipo_contrato: string;
  campos: { [key: string]: string };
  clausula_extra?: string;
}
export interface Template {
  name: string;
  fields: string[];
}
export interface GPTClauseRequest {
  prompt: string;
}
export interface GPTClauseResponse {
  clause: string;
  source: string; // "gpt" o "simulado"
}
ğŸ¯ Requisitos tÃ©cnicos:
MÃ³dulo independiente: Reusable y limpio
NavegaciÃ³n: Agregar al menÃº debajo de "Documentos" con Ã­cono de contratos
Hijos del menÃº: "Generar Contratos" y "Generar ClÃ¡usula"
Actualizar: sidebar-items.ts y traducciones en i18n (espaÃ±ol, inglÃ©s, alemÃ¡n)
Imports: HttpClient, ReactiveFormsModule
UX: Loader al generar, manejo de errores, SnackBar para notificaciones
Layout: Seguir la lÃ³gica de document-dashboard
ğŸ”„ Funcionalidades adicionales:
Vista previa: Mostrar campos antes de generar
ValidaciÃ³n: Formulario con mensajes especÃ­ficos
BotÃ³n: "Limpiar formulario"
Descarga automÃ¡tica: Al recibir el blob del backend
ğŸ“Š Flujo completo:
Cargar plantillas â†’ /api/v1/templates
Seleccionar tipo â†’ /api/v1/test-template/{name} (obtener campos)
Llenar campos â†’ Formulario dinÃ¡mico
Generar contrato â†’ /api/v1/generate-contract â†’ Descarga automÃ¡tica
Descargar plantilla â†’ /api/v1/download-template/{name} (opcional)
ğŸ› ï¸ Manejo de archivos:
Respuesta del backend: application/vnd.openxmlformats-officedocument.wordprocessingml.document
Descarga automÃ¡tica: Crear enlace temporal y trigger click
Nombre del archivo: contrato_{tipo}_{cliente}.docx
âš ï¸ Puntos importantes:
NO borrar: MetodologÃ­a anterior que sirve
Reutilizar: Servicios existentes como base
Consistencia: Seguir patrones del proyecto actual
Responsividad: Asegurar funcionalidad en mÃ³viles
Este prompt complementado incluye toda la informaciÃ³n del backend necesaria para crear un mÃ³dulo completamente funcional e integrado con tu API existente.